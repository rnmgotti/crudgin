1. Можешь использовать вместо c.JSON и c.Abort один метод c.AbortWithStatusJSON. Работать будет идентично, а кода будет меньше. )

2. В некоторых местах  у тебя дублируются модели. К примеру CreateProductsInput и UpdateProductsInput. Нет нужды их дублировать, они совершенно одинаковые. Можно создать единый тип Products и использовать его в нескольких функциях.
 
//////3. В сущности продуктов у тебя product.go вместо service.go 

4. Я заметил, что в некоторых местах ты обрабатываешь ошибку при GORM запросе, а в некоторых местах нет. Рекомендую обрабатывать ошибки при GORM запросах везде.

//////5. В сущности продуктов у тебя вся работа с DB запросами лежит внутри функций, находящихся в Service части. А репозиторий пустой. В user такого не заметил.

6. Если хочешь проверить на существование в базе какой-либо элемент, можешь не делать полный селект структуры, проще будет сделать SELECT COUNT(), почитай об этом. Он вернёт цифру - количество элементов с заданными критериями. Таким образом не будет лишней переменки которую использовать не будешь, и так безопаснее, потому что при отсутствии в таблице результата он вернёт гарантированно 0.

7. В репозиторий передаются только данные и ответная модель. Gin контекст не уходит из уровня api. В сущности user у тебя гоняется по функциям GIn Context. Вместо этого, передавай в сервис функцию данные которые ты возьмёшь из gin контекста на уровне обработчика/handler'а. В репозитории ситуация аналогичная - данные из сервиса идут в репозиторий.

8. При логине я увидел, что ты после селекта First проверяешь ответ по RowsAffected. По сути, он будет всегда нулевым, потому что это значение показывает, сколько рядов в БД изменилось. И подходит оно при UPDATE, INSERT, DELETE, но не SELECT.

9. Когда открываешь DB соединение, рекомендуется defer функцией его так же закрывать. У gorm'а есть возможность вытащить оригинальный sql.DB, и его уже можно будет закрыть. Может случиться что-нибудь, и соединение не закроется.